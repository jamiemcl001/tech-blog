<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jamie McLeish's Blog - Tech Ramblings</title>
    <description>A blog to house all of the tech thoughts running around my head</description>
    <link>https://jamiemcl.tech//</link>
    <atom:link href="https://jamiemcl.tech//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 11 Jan 2020 17:49:09 +0000</pubDate>
    <lastBuildDate>Sat, 11 Jan 2020 17:49:09 +0000</lastBuildDate>
    <generator>Jekyll v3.6.3</generator>

    
      <item>
        <title>Enabling Multi-Region Restricted Communications with AWS VPC Peering &amp; Route 53 Private Hosted Zones</title>
        <description>&lt;p&gt;Hi again,&lt;/p&gt;

&lt;p&gt;I‚Äôve recently encountered another problem when using AWS for my side projects. To be clear it‚Äôs not an actual problem in AWS but I feel that a blog post may help someone in future who is trying to enable restricted communication between VPCs in different regions.&lt;/p&gt;

&lt;p&gt;I‚Äôm conscious of the fact that I want to make this example as easy to follow as possible - so we‚Äôll work with the following example:&lt;/p&gt;

&lt;p&gt;Let‚Äôs say I have a server running in the &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; region in AWS. This is an extremely simple server app, that when invoked with the path &lt;code class=&quot;highlighter-rouge&quot;&gt;/say-hello?name=Angela&lt;/code&gt; it will return the following response:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello, Angela!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For convenience I‚Äôve pushed a repository to the Docker Hub that will easily start a server that will do just this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run -dt --rm -p 80:8080 jamiemcl001/say-hello-server:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let‚Äôs say that we have another service running in a different region (lets say North Virginia or &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt;). If we presume that this new EC2 instance needs to consume the service in the other region then there are a couple of ways that we could do this.&lt;/p&gt;

&lt;p&gt;First off, we could ensure that the first service has a publicly accessible endpoint, and set up our security groups so that port 80 could always be accessed via the outside world. Now this doesn‚Äôt seem so bad with our very contrived example, but what if we actually had sensitive data returned as part of this API call? I know that I wouldn‚Äôt feel too comfortable about having that available for anyone to hit and potentially hack‚Ä¶&lt;/p&gt;

&lt;p&gt;So, what‚Äôs our other option? We could ensure that our server has no publicly accessible IP address and instead look to communicate from within our private VPC‚Äôs? This is far more desirable, but at the same time, just how easy is it?&lt;/p&gt;

&lt;p&gt;Well it turns out that it‚Äôs very easy if we had two services sat in the same VPC that wanted to communicate with each other. In the AWS console we would see something like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15_02_04.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15_02_04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we could easily just run a cURL command on another EC2 instance in the same VPC and successfully see our response. Running &lt;code class=&quot;highlighter-rouge&quot;&gt;curl ip-172-30-0-224.eu-west-1.compute.internal/say-hello?name=Angela&lt;/code&gt; gives us back our expected &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, Angela!&lt;/code&gt; response!&lt;/p&gt;

&lt;p&gt;The problem arises when we try and hit the endpoint &lt;code class=&quot;highlighter-rouge&quot;&gt;ip-172-30-0-224.eu-west-1.compute.internal&lt;/code&gt; from an instance that isn‚Äôt in the same VPC as the other. It will simply fail to resolve it and instead we‚Äôll see an error like &lt;code class=&quot;highlighter-rouge&quot;&gt;ping: ip-172-30-0-224.eu-west-1.compute.internal: Name or service not known&lt;/code&gt;. So, how do we get around this now???&lt;/p&gt;

&lt;h2 id=&quot;creating-a-vpc-peering-connection&quot;&gt;Creating a VPC Peering Connection&lt;/h2&gt;

&lt;p&gt;If we go to the VPC console in AWS we can see an option down the sidebar which is named ‚ÄúPeering Connections‚Äù. Creating a new Peering Connection will allow us to set up routing in AWS which means that the two individual VPCs will be able to see one another. Click on ‚ÄúCreate Peering Connection‚Äù and we will go through all of the options‚Ä¶&lt;/p&gt;

&lt;p&gt;First off you will want to begin with copying the ID of the VPC you would like your North Virginia VPC to connect to. So if we change regions to &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; and take a look we will see the only VPC we have available in Ireland is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15_24_33.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15_24_33.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Make a note of the VPC ID (and the IPv4 CIDR block as we will be needing that later on in this post), and then switch regions back to &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt;, so that we can set up our peering connection.&lt;/p&gt;

&lt;p&gt;Now that we have the ID and are back in our selected region we can input all of the information required to setup the connection. When you click on the VPC (Requester)* checkbox you will be presented with a dropdown box of all the VPCs in your current region. As we have only one we can go ahead and select it immediately.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15_20_18.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15_20_18.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The only other thing we need to change from the defaults is that the VPC we would like to peer with is in another region, and we need to paste in the ID of the VPC we want to connect with in Ireland. Once you click ‚ÄúCreate Peering Connection‚Äù it will set up a peering request that we will need to go ahead and accept in the other region. Let‚Äôs go ahead and change our region back to &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; so that we can accept it‚Ä¶&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15_31_51.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15_31_51.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we right click on the row of the peering connection then we are presented with the option to Accept the peering connection. If we click this then a popup will show just to present us with all of the information of the connection and we can hit accept and have it be enabled.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that a popup will immediately show to ask you to set up the routing tables. We will do this, but not just yet. We want to enable one more thing first‚Ä¶&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Once the peering connection has been created we want to make it so that our service that is located in the US can resolve to the private hostnames in our &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; VPC. In order to do this, select the connection and right click. Among the options, there is an option to ‚ÄúEdit DNS Settings‚Äù - lets set this up by clicking this and we‚Äôll see the following screen:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15_39_41.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15_39_41.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Selecting the option ‚ÄúAccepter DNS resolution‚Äù means that the hostname we were trying to resolve earlier from the US service (&lt;code class=&quot;highlighter-rouge&quot;&gt;ip-172-30-0-224.eu-west-1.compute.internal&lt;/code&gt;) will now actually be able to resolve successfully, so lets select it and hit save.&lt;/p&gt;

&lt;p&gt;Now that we have set up the peering connection correctly we need to ensure that our US service actually knows how to route requests that are intended for the &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; service through the peering connection, and not just drop those requests on the floor. To do this we need to first change our region back to &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; and then go into the ‚ÄúRoute Tables‚Äù section of the VPC console.&lt;/p&gt;

&lt;p&gt;You‚Äôll need to go ahead and select the route table associated with the VPC that we have just set up the peering connection for, and then right click and select ‚ÄúEdit Routes‚Äù. (This is where we‚Äôll need the IPv4 CIDR block from our European region, as I mentioned earlier‚Ä¶)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_15.48.28.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_15.48.28.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We‚Äôll want to go ahead and hit ‚ÄúAdd route‚Äù and paste in the IPv4 CIDR block for our &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; VPC, so that all IP calls/DNS requests that resolve to the that block will be routed through the peering connection. If we click on the target dropdown we‚Äôll want to select ‚ÄúPeering Connection‚Äù and then the name of the Peering connection we inputted when we first created it. Hit save and this will begin to propagate through all of our VPC.&lt;/p&gt;

&lt;p&gt;Now we want to enable bi-directional communication - so we‚Äôll go ahead and change the DNS settings for the peering connection to allow hostname resolving from the acceptor VPC (note that we‚Äôll have to change the DNS settings in our &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; region to allow the acceptor to resolve the hostnames), and then setup routing in our &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; VPC to route calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;10.0.0.16&lt;/code&gt; (as this is the CIDR block for our US VPC) through the same peering connection. This will enable our service in Europe to communicate back with the US VPC.&lt;/p&gt;

&lt;p&gt;With all of these changes, if we now SSH into the US EC2 instance we can try and make our API call once again:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl ip-172-30-0-224.eu-west-1.compute.internal/say-hello?name=Angela&lt;/code&gt; will return us with &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, Angela!&lt;/code&gt; üéâüéâüéâ&lt;/p&gt;

&lt;h2 id=&quot;taking-it-one-step-further-with-route-53-private-hosted-zones&quot;&gt;Taking it one step further with Route 53 Private Hosted Zones&lt;/h2&gt;

&lt;p&gt;OK, so now we can hit an endpoint from a different VPC - job done, right? Well we could go one step further and make it so that instead of hitting the endpoint &lt;code class=&quot;highlighter-rouge&quot;&gt;ip-172-30-0-224.eu-west-1.compute.internal&lt;/code&gt; directly, we could hit an endpoint like, say, &lt;code class=&quot;highlighter-rouge&quot;&gt;api.internal&lt;/code&gt; and be able to resolve in the same way as before. But how do we do this?&lt;/p&gt;

&lt;p&gt;Amazon Route53 is a fully fledged DNS service, and one of it‚Äôs features is ‚ÄúPrivate Hosted Zones‚Äù. This feature allows you to create DNS entries that will be accessible to services within associated VPCs.&lt;/p&gt;

&lt;p&gt;We‚Äôll start off by creating a new Private Hosted Zone. We‚Äôll do this by going to Route53 and clicking ‚ÄúCreate Hosted Zone‚Äù, and we can fill in the form with the following details:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_17_03_18.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_17_03_18.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By default, the ‚ÄúType‚Äù will be ‚ÄúPublic Hosted Zone‚Äù - this means that it will be for a domain name that is publicly available to everyone on the internet. We don‚Äôt want this - we only want the records contained within this zone to be available to services inside our VPCs. We will want to go ahead and select one of the VPCs that we intend to use, so I‚Äôve gone ahead and selected the &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; VPC. At the moment you can only select one VPC (at the moment you can only select the one VPC when creating it so we‚Äôll retrospectively add the second VPC after.&lt;/p&gt;

&lt;p&gt;Now that we‚Äôve created this &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt; hosted zone we can go ahead and add a record for the &lt;code class=&quot;highlighter-rouge&quot;&gt;api&lt;/code&gt; subdomain. Click ‚ÄúCreate Record Set‚Äù and we‚Äôll create a CNAME record which points the &lt;code class=&quot;highlighter-rouge&quot;&gt;api&lt;/code&gt; subdomain to the previously unmemorable &lt;code class=&quot;highlighter-rouge&quot;&gt;ip-172-30-0-224.eu-west-1.compute.internal&lt;/code&gt; domain, and now that is done. If we were to allow the Route53 DNS services to propagate (which tends to be pretty quick in my experience) - we could then go into any EC2 instance in our EU VPC and hit &lt;code class=&quot;highlighter-rouge&quot;&gt;api.internal/say-hello?name=Angela&lt;/code&gt; and we would get the response that we expect‚Ä¶&lt;/p&gt;

&lt;p&gt;But, what we want is to be able to access the memorable &lt;code class=&quot;highlighter-rouge&quot;&gt;api.internal&lt;/code&gt; domain from our US EC2 instances. So let‚Äôs go back and add associate the US VPC with the private hosted zone that we‚Äôve just set up. To do this we need to go back to the ‚ÄúHosted Zones‚Äù page in Route53, and select the radio button next to our &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt; zone.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_17_17_12.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_17_17_12.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we click in the VPC ID text box then we‚Äôll be presented with the same dropdown box as before, and we can now select the &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; VPC that we‚Äôve been using throughout this post. Select that and hit ‚ÄúAssociate New VPC‚Äù. This will make the private zone available in both the &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;eu-west-1&lt;/code&gt; VPCs. ü§Øü§Ø&lt;/p&gt;

&lt;p&gt;One quick side note is to take note of the ‚ÄúImportant‚Äù information box that is shown in the above screenshots as I ignored them initially and lost some time, wondering why I couldn‚Äôt see any of the records in my &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; EC2 instance. You‚Äôll need to double check and ensure that DNS Hostnames and DNS Support is supported in all of the VPCs listed in your ‚Äúassociated VPCs‚Äù section. To do this go to the VPC console &lt;em&gt;(you‚Äôll need to do this individually for each region, unfortunately).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Once you‚Äôre in the VPC console select the VPC you would like to check these properties for. When you select it you will see the information box at the bottom of the page which should look something like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/enabling_multi_vpc_communication/Screenshot_2020-01-11_at_17_26_50.png&quot; alt=&quot;Enabling%20Multi%20Region%20Restricted%20Communications%20wi/Screenshot_2020-01-11_at_17_26_50.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the DNS resolution and DNS hostnames are enabled. If, for whatever reason yours are disabled then (with the VPC selected) click on the ‚ÄúActions‚Äù button above the VPC list and click ‚ÄúEdit DNS resolution‚Äù or ‚ÄúEdit DNS hostnames‚Äù (or both if both are disabled). Tick the checkbox in the next page to enable these properties, and then hit save. Once all of these steps have been completed we should be able to SSH into our &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt; EC2 box and execute the following command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl api.internal/say-hello?name=Angela
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we should be given the result &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, Angela!&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;üéâüéâüéâüéâ&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Well, it‚Äôs been a bit of a longer post than I initially intended - but it is my hope that someone who comes across a similar problem has a complete set of actions to fix their issue. Thank you very much for taking the time to read this, I hope it was informative and just a little bit interesting üòä.&lt;/p&gt;

&lt;p&gt;I‚Äôll catch you in the next blog post, whenever that may be!&lt;/p&gt;

&lt;p&gt;Jamie.&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Jan 2020 17:42:00 +0000</pubDate>
        <link>https://jamiemcl.tech//awsvpc/2020/01/11/multi-vpc-communications/</link>
        <guid isPermaLink="true">https://jamiemcl.tech//awsvpc/2020/01/11/multi-vpc-communications/</guid>
      </item>
    
      <item>
        <title>Communicating between Docker Containers, the Host Machine etc.!</title>
        <description>&lt;p&gt;Hi all,&lt;/p&gt;

&lt;p&gt;During our time at work we recently came across an issue when using LocalStack for testing. We had two containers spun up as part of a &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose&lt;/code&gt; stack, and needed to be able to communicate between the two containers. After spending some time looking through StackOverflow we realised where we were going wrong. Thus - the inspiration for this blog post (the first on my new tech blog üéâ) was born.&lt;/p&gt;

&lt;p&gt;Rather than using this example throughout the post I‚Äôll simplify it even further to demonstrate. Say, for example, I have a simple Express server running on port 8080 of my local machine. When I make a GET request to the endpoint &lt;code class=&quot;highlighter-rouge&quot;&gt;/say-hello&lt;/code&gt; with a name passed as a query parameter, I want to be nice and say hello to the fine person.&lt;/p&gt;

&lt;p&gt;But what happens if I want to move the app over to execute on another host machine? Let‚Äôs say that we have been developing and running the server on a *NIX based machine and we needed to migrate over to run this on a Windows machine? In this simplistic example we wouldn‚Äôt expect to see any problems when we try run our app - but what if we were developing something much more complex than a simple server? We could easily run into issues that may only be encountered in a specific Operating System. So‚Ä¶ Docker to the rescue. For anyone that hasn‚Äôt played around with Docker as yet, it basically provides users with the ability to run commands/applications in a completely containerised environment - something that should make the different operating systems problem a thing of the past.&lt;/p&gt;

&lt;p&gt;Listed above is just one of the many advantages of running our applications in a containerised environment - and if we start to run multiple containers alongside each other, we may want to be able to communicate between those - how do we do this? This article covers the following scenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Communicating with a Docker container from the host machine&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communicating with the host machine from inside a Docker container&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communicating with another Docker container from inside a Docker container&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let‚Äôs begin‚Ä¶&lt;/p&gt;

&lt;h3 id=&quot;communicating-with-a-docker-container-from-the-host-machine&quot;&gt;&lt;strong&gt;Communicating with a Docker container from the host machine:&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;If you clone &lt;a href=&quot;https://github.com/jamiemcl001/say-hello-server&quot;&gt;this repository&lt;/a&gt;, and run the command &lt;code class=&quot;highlighter-rouge&quot;&gt;docker build -t sample-node .&lt;/code&gt;, you will be able to run a container with this image. We will be using this image throughout the course of this blog post. Running the image in a newly constructed container is simple with the following command:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8080:8080 sample-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The magic behind being able to connect to this container is the &lt;code class=&quot;highlighter-rouge&quot;&gt;-p 8080:8080&lt;/code&gt; parameter. When used, this parameter will automatically map port 8080 of the docker container to port 8080 on your local machine. If you would rather use the standard port 80 to make requests then you could use the parameter, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;-p 80:8080&lt;/code&gt;. This will map port 80 of your localhost to port 8080 of the docker container.&lt;/p&gt;

&lt;p&gt;With the previous commands being run - the local machine should be able to communicate directly with the docker host using the &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt; name. Running &lt;code class=&quot;highlighter-rouge&quot;&gt;curl localhost:8080/say-hello?name=John&lt;/code&gt; should result in you seeing &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, John&lt;/code&gt; in the terminal. Hooray!&lt;/p&gt;

&lt;h3 id=&quot;communicating-with-the-host-machine-from-inside-a-docker-container&quot;&gt;&lt;strong&gt;Communicating with the host machine from inside a Docker container:&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Unfortunately this way is much more tricky and not standard between different operating systems, although the use cases for it are more limited than, say, container &amp;lt;-&amp;gt; container communication and host machine -&amp;gt; container communication. Instructions for Windows machines will be added shortly &lt;em&gt;(unfortunately I don‚Äôt readily have access to a Windows machine to test)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Working with OSX&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker can automatically resolve the hostname &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.for.mac.host.internal&lt;/code&gt; when we run containers using the default bridge network. As such I can run the following command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -ti alpine /bin/sh
apk add curl
curl docker.for.mac.host.internal:8080/say-hello?name=John
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If I want to do the same but with an easier to remember hostname (remembering to type out &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.for.mac.host.internal&lt;/code&gt; every time could become quite cumbersome then I can execute the following command to provide the hostname &lt;code class=&quot;highlighter-rouge&quot;&gt;local&lt;/code&gt; instead.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; sample_app &lt;span class=&quot;nt&quot;&gt;--add-host&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;:&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;ipconfig getifaddr en0&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; alpine /bin/sh
apk add curl
curl &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;:8080/say-hello?name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;John
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both examples listed above should result in the response &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, John!&lt;/code&gt; being shown in the terminal.&lt;/p&gt;

&lt;p&gt;For context, the &lt;code class=&quot;highlighter-rouge&quot;&gt;--add-host&lt;/code&gt; parameter will automatically add a record into the &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; file of the container. This essentially means that if you use the command &lt;code class=&quot;highlighter-rouge&quot;&gt;--add-host local:192.16.0.2&lt;/code&gt;, then inspect the value of the hosts file - you should see something along the lines of the following:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
192.16.0.2 &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;172.17.0.3      3c6f479965ad
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Therefore, when you make requests to &lt;code class=&quot;highlighter-rouge&quot;&gt;local&lt;/code&gt; - the machine will first look in this file - find an associated record for the hostname &lt;code class=&quot;highlighter-rouge&quot;&gt;local&lt;/code&gt; and therefore redirect the request to &lt;code class=&quot;highlighter-rouge&quot;&gt;192.16.0.2&lt;/code&gt; without needing to go to the external network.&lt;/p&gt;

&lt;p&gt;Please note that this is tested using OSX Catalina - unfortunately I don‚Äôt have access to an earlier version of OSX to test if the &lt;code class=&quot;highlighter-rouge&quot;&gt;ipconfig getifaddr en0&lt;/code&gt; works as expected, if it doesn‚Äôt then please do let me know and I‚Äôll try and document a more reliable method. This command, when executed directly in the terminal will echo the local network‚Äôs IP address for your machine. &lt;em&gt;There could be other network interfaces that you may need to check for in order to get this working. If anyone has a nicer way of retrieving the local IP of your machine then please mention them in the comments.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Working with Linux&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Disclaimer: I‚Äôve only tested this with an earlier version of Fedora (Fedora 27 to be exact) but I believe it should work on other Linux based OS‚Äôes. If anyone should encounter any issues then please let me know and I‚Äôll update the post with the appropriate method.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Running Docker in Linux seems a little less fiddly than using it with OSX. The reason for this is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;--network host&lt;/code&gt; parameter works as you‚Äôd expect it to. If we begin by running our server on our local machine (&lt;code class=&quot;highlighter-rouge&quot;&gt;node src/server.js&lt;/code&gt;), we can then easily allow our future containers to be able to communicate with it. Let‚Äôs launch a new container using the super minimal &lt;code class=&quot;highlighter-rouge&quot;&gt;alpine&lt;/code&gt; image.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host alpine
apk add curl
curl localhost:8080/say-hello?name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;John
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we should see the message &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello John!&lt;/code&gt; echoed back to us. See - much simpler than what we had to go through on OSX.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Working with Windows&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately I haven‚Äôt had a chance to test the approaches required on Windows. Apologies for this - I‚Äôll check this shortly and update the post with the appropriate method.&lt;/p&gt;

&lt;h3 id=&quot;communicating-with-another-docker-container-from-inside-a-docker-container&quot;&gt;&lt;strong&gt;Communicating with another Docker container from inside a Docker container:&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;There are a few different ways of doing this, and I‚Äôll document my preferred approach: using a custom Docker network.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Using a custom network:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Lets begin by creating a new network in Docker. This post will not go into much detail about how networking works in Docker - although if we simply create a new network we can look at it as creating a sub-network that Docker will manage and allow containers to connect to.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker network create private_network
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this command we have created a private bridge network named &lt;code class=&quot;highlighter-rouge&quot;&gt;private_network&lt;/code&gt; in Docker. Containers that are attached to this network will be able to communicate with each other as if they are on their own private LAN. This is a really nice feature of Docker and something that I‚Äôll definitely be looking further into and discussing in the future.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; sample-node &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; private_network sample-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we deconstruct this command - we are creating a container as we usually would do - but we are also adding the &lt;code class=&quot;highlighter-rouge&quot;&gt;--network private_network&lt;/code&gt; parameter. This tells Docker to attach this newly running container to the private bridge network when it is launched. We can do this by running the command &lt;code class=&quot;highlighter-rouge&quot;&gt;docker network inspect private_network&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you look at the output of this command, you should see a lot of the networks internals - but the thing that we are particularly interested in is the &lt;code class=&quot;highlighter-rouge&quot;&gt;Containers&lt;/code&gt; object. This lists any containers that are currently attached to this internal network. At this point we should only see one container listed in this response - our newly created &lt;em&gt;sample-node&lt;/em&gt; container.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;s2&quot;&gt;&quot;Containers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;6ab48ccea7334c0dbc6469f5d0fa78ac9522ef2b806c25dd91beb22792143447&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;Name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sample-node&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;EndpointID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;MacAddress&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;IPv4Address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;172.20.0.2/16&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;IPv6Address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This output essentially means that if any other containers should connect to the network - they will also be able to see others connected. We can demonstrate this by launching a throwaway container on the same network (&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -ti --rm --network private_network alpine /bin/sh&lt;/code&gt;) and pinging &lt;code class=&quot;highlighter-rouge&quot;&gt;172.20.0.2&lt;/code&gt;, seeing the following output:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PING 172.20.0.2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;172.20.0.2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 56 data bytes
64 bytes from 172.20.0.2: &lt;span class=&quot;nv&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;64 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.320 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker also allows us to connect to other containers on the same network by their Container ID and their Container name. As a result, this makes it much easier for us to be able to communicate between them. This will mean that the docker bridge will resolve &lt;code class=&quot;highlighter-rouge&quot;&gt;sample-node&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;172.20.0.2&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; private_network alpine /bin/sh
apk add curl
curl sample-node:8080/say-hello?name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;John
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we should see &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello John&lt;/code&gt; in our terminal output! üéâüéâüéâ&lt;/p&gt;

&lt;p&gt;If users wish to use &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose&lt;/code&gt; instead of the Docker CLI to construct the containers then I‚Äôll also provide a &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; file that can be used to demonstrate the same approach:&lt;/p&gt;

&lt;div class=&quot;language-docker highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: &quot;3.7&quot;

services:
    sample-node:
        image: sample-node
        container_name: sample-node
        networks:
            - default
    alpine:
        image: alpine
        container_name: alpinetest
        depends_on:
            - sample-node
        tty: true
    networks:
        - default

networks:
    default:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up -d&lt;/code&gt; will start both of these containers and place them onto the same network on launch. Using the empty network object &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; empty will create a new bridge network automatically and attach both containers to it on launch, while using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; parameter in docker-compose will launch all containers in detached mode. First off lets check that both containers are running as expected with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                  NAMES
e4a73515163c        alpine                 &lt;span class=&quot;s2&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;                7 hours ago         Up 7 hours                                 alpinetest
3e682b2adb74        sample-node            &lt;span class=&quot;s2&quot;&gt;&quot;node server.js&quot;&lt;/span&gt;         7 hours ago         Up 7 hours          8080/tcp               sample-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can tell from the output above, we have both containers running as expected, and we can move on to try executing commands within these containers. We can gain access to them by using the name we defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;container_name&lt;/code&gt; for each object. As such - lets gain access to the default shell in the &lt;code class=&quot;highlighter-rouge&quot;&gt;alpinetest&lt;/code&gt; image, just to check that we can resolve the server as expected:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; alpinetest /bin/sh
apk add curl
curl sample-node:8080/say-hello?name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;John
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we see our ‚ÄúHello John‚Äù output, as expected! ü§Øü§Øü§Ø&lt;/p&gt;

&lt;p&gt;By this point I feel that we‚Äôve got a good enough understanding of how we can communicate between containers, as well as communicating with the host machine as well. This weekend has been eye opening to just how powerful Docker is and how we can use it for more things in our everyday work environment and I‚Äôll certainly be taking the time to learn more about it. I‚Äôll try and ensure that whenever something interesting does crop up - I‚Äôll try and write it up for future reference. I do hope that you found this article interesting and it has given you the opportunity to learn something new about Docker. I look forward to putting together the next blog post for this site.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Jamie.&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Nov 2019 15:39:00 +0000</pubDate>
        <link>https://jamiemcl.tech//docker/2019/11/16/docker-inter-container-communication/</link>
        <guid isPermaLink="true">https://jamiemcl.tech//docker/2019/11/16/docker-inter-container-communication/</guid>
      </item>
    

    
      
        
      
    
      
        
          <item>
            <title>Contact Me</title>
            <description>&lt;!-- modify this form HTML and place wherever you want your form --&gt;

&lt;form action=&quot;https://formspree.io/mjvvzwoj&quot; method=&quot;POST&quot;&gt;
  &lt;label&gt;
    Your name:
    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Your email:
    &lt;input type=&quot;text&quot; name=&quot;_replyto&quot; /&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Your message:
    &lt;textarea name=&quot;message&quot; rows=&quot;9&quot;&gt;&lt;/textarea&gt;
  &lt;/label&gt;

  &lt;!-- your other form fields go here --&gt;

  &lt;button type=&quot;submit&quot; class=&quot;c-btn&quot;&gt;Send&lt;/button&gt;
&lt;/form&gt;
</description>
            <link>https://jamiemcl.tech//contact.html</link>
          </item>
        
      
    
      
    
      
    

  </channel>
</rss>